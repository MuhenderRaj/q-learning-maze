/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.muhender.qtable.UI;

import com.muhender.network.NeuralNetwork;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JPanel;


/**
 *
 * @author R Muhender Raj
 */
public class DrawArea extends JPanel implements Runnable{
    Random r;
    long episode = 1, successes = 0;
    public static double speedupFactor = 1;
    double e = 1 / Math.sqrt(episode + 2);    //to determine exploration vs exploitation probabilities
    double gamma = 0.99;    //discount factor
    int board[][], rewards[][]; 
    double qValues[][];    //displays targetNet q values for each state. Updated whenever predictionNet is copied to targetNet
    public static int player[], playerGhost[], prevState[], endState[];
    int moves = 0;
    int copyTime = 500;
    public static NeuralNetwork predictionNet, targetNet;
    int layerInfo[];
    boolean lastState = false;
    
    /**
     * Creates new form DrawArea
     */
    public DrawArea() {
        r = new Random();
        
        
        initComponents();
        board = new int[][]{
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0},
            {0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0},
            {0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0},
            {0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0},
            {0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0},
            {0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0},
            {0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0},
            {0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        };
        
        
        
        rewards = new int[board.length][board[0].length];
        qValues = new double[board.length][board[0].length];
         
        for(int i = 0; i < rewards.length; i++){
            
            for(int j = 0; j < rewards[i].length; j++){
                switch(board[i][j]){
                    case 1:
                        rewards[i][j] = -1;
                        break;
                    case 0:
                        rewards[i][j] = -100;
                        break;
                }
                
                qValues[i][j] = 0;
            }        
        }
        
        player = new int[]{1, 1};
        playerGhost = new int[]{1, 1};
        prevState = new int[]{1, 1};
        endState = new int[]{board[board.length - 1].length - 2, board.length - 2};
        
        rewards[endState[1]][endState[0]] = 100;
        
        new Thread(this, "DrawArea").start();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        moveRate = new javax.swing.JLabel();
        episodeNum = new javax.swing.JLabel();
        successNum = new javax.swing.JLabel();
        speed = new javax.swing.JSlider();
        showQ = new javax.swing.JCheckBox();

        setBackground(new java.awt.Color(102, 255, 51));
        setPreferredSize(new java.awt.Dimension(1080, 720));

        moveRate.setText("1 second(s) per move");

        episodeNum.setText("episode 1");

        successNum.setText("0 successes");

        speed.setMaximum(1001);
        speed.setValue(1);

        showQ.setText("Show Q Values");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(42, 42, 42)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(showQ)
                    .addComponent(moveRate, javax.swing.GroupLayout.PREFERRED_SIZE, 155, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(successNum, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(episodeNum, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 90, Short.MAX_VALUE))
                    .addComponent(speed, javax.swing.GroupLayout.PREFERRED_SIZE, 448, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(50, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(378, Short.MAX_VALUE)
                .addComponent(showQ)
                .addGap(18, 18, 18)
                .addComponent(speed, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(moveRate, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(episodeNum, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(successNum, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(176, 176, 176))
        );
    }// </editor-fold>//GEN-END:initComponents

    @Override
    protected void paintComponent(Graphics g){
        super.paintComponent(g);
        Graphics2D g2D = (Graphics2D)g;
        g2D.setFont(new Font("Arial", Font.PLAIN, 10));
        
        if(board != null)
            for(int i = 0; i < board.length; i++){
                for(int j = 0; j < board[i].length; j++){

                    switch(board[i][j]){
                        case 1:
                            g2D.setColor(Color.BLUE);
                            break;
                        case 0:
                            g2D.setColor(Color.RED);
                            break;
                    }

                    g2D.fillRect(j * 30, i * 30, 30, 30);
                    
                    if(showQ.isSelected()){
                        g2D.setColor(Color.WHITE);
                        g2D.drawString("" +  ((float)(Math.round(qValues[i][j] * 10)) / 10f), j * 30, i * 30 + 15);
                    }
                    
                    if(player[1] == i && player[0] == j){
                        g2D.setColor(Color.YELLOW);
                        g2D.fillOval(j * 30 + 5, i * 30 + 5, 20, 20);
                        
                    }
                }
            }
        
    }
    
    public void move(int i, int play[]){
        switch(i){  //urdl
            case 0:
                play[1] -= 1;
                break;

            case 1:
                play[0] += 1;
                break;

            case 2:
                play[1] += 1;
                break;

            case 3:
                play[0] -= 1;
                break;
        }
    }
    
    @Override
    public void run() {
        repaint();
        
        
        while(true){
            try {
                long sleepTime = (long)(1000 / speed.getValue());
                Thread.sleep(sleepTime);
                moveRate.setText((double)sleepTime / 1000 + " seconds per move");
            } catch (InterruptedException ex) {
                Logger.getLogger(DrawArea.class.getName()).log(Level.SEVERE, null, ex);
            } 
            
            int max = 0;
            double qMaxTemp = -Double.MAX_VALUE;
            
            for(int i = 0; i < 4; i++){

                playerGhost = player.clone();
                move(i, playerGhost);
                if(qMaxTemp < qValues[playerGhost[1]][playerGhost[0]]){
                    qMaxTemp = qValues[playerGhost[1]][playerGhost[0]];
                    max = i;
                }
            }
            
            if(r.nextDouble() < e){
                int thought = max;
                do{
                    max = r.nextInt(4);
                } while(thought == max);
            }
            
            prevState = player.clone();
            move(max, player);
            
            moves++;
            
            double qMax = -Double.MAX_VALUE;
            
            
            for(int i = 0; i < 4; i++){    //urdl. To calculate Qmax for each direction
                playerGhost = prevState.clone();
                move(i, playerGhost);
                
                if(qMax < qValues[playerGhost[1]][playerGhost[0]])
                    qMax = qValues[playerGhost[1]][playerGhost[0]];
            }
            
            
            lastState = (player[0] == endState[0] && player[1] == endState[1]);

            qValues[prevState[1]][prevState[0]] += 
                    0.01 * (rewards[prevState[1]][prevState[0]] + gamma * qMax - qValues[prevState[1]][prevState[0]]);
            
            if(lastState || board[player[1]][player[0]] == 0){
                if(lastState){
                    successes++;
                    successNum.setText(successes + " successes");
                }
                
                repaint();
                qValues[player[1]][player[0]] = rewards[player[1]][player[0]];
                
                episode++;
                player = new int[]{1, 1};
                e = 1 / Math.sqrt(episode + 2);
                moves = 1;
                episodeNum.setText("episode " + episode);
            }
            
            revalidate();
            repaint();
        }
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel episodeNum;
    private javax.swing.JLabel moveRate;
    private javax.swing.JCheckBox showQ;
    private javax.swing.JSlider speed;
    private javax.swing.JLabel successNum;
    // End of variables declaration//GEN-END:variables
}
